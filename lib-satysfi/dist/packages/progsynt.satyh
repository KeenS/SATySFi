@require: pervasives
@require: list
@require: math

module Term : sig
  type t
  val var : math -> t
  val letin : t -> t -> t -> t
  val app : t -> t -> t
  direct \term : [t] math-cmd
end = struct

  type t = (| math : math; assoc : int; |)

  let-math \token m =
    math-color (RGB(0., 0., 0.5)) (math-char-class MathBoldRoman m)

  let-math \sp =
    text-in-math MathOrd (fun ctx -> inline-skip (get-font-size ctx *' 0.5))

  let var m =
    (| math = m; assoc = 0; |)

  let letin x e1 e2 =
    let mx = x#math in
    let m1 = e1#math in
    let m2 = e2#math in
      (|
        math = ${\token{let}\sp #mx = #m1 \sp\token{in}\sp #m2};
        assoc = 0;
      |)

  let app e1 e2 =
    let m1 = e1#math in
    let m2 = e2#math in
      (|
        math = ${m1\sp#m2};
        assoc = 0;
      |)

  let-math \term tm =
    tm#math

end


let insert-bars mlst =
  mlst |> List.fold-left-adjacent (fun macc m moptprev _ -> (
    match moptprev with
    | None -> m
    | _    -> ${#macc \mid #m}
  )) ${}


let-block ctx +BNF mnontm mlstlst =
  let sz = get-font-size ctx in
  let vpad = sz *' 0.25 in
  let padsL = (0pt, sz *' 0.5, vpad, vpad) in
  let padsR = (0pt, 0pt, vpad, vpad) in
  let celllstlst =
    mlstlst |> List.fold-lefti (fun i acc mlst -> (
      let c0 =
        if i == 0 then
          NormalCell(padsL, embed-math ctx ${#mnontm \mathrel{::=}})
        else
          NormalCell(padsL, inline-fil ++ embed-math ctx ${\mid})
      in
      let ib = embed-math ctx (insert-bars mlst) ++ inline-fil in
      [c0; NormalCell(padsR, ib)] :: acc
    )) [] |> List.reverse
  in
  let ib = tabular celllstlst (fun _ _ -> []) in
  line-break true true ctx (inline-fil ++ ib ++ inline-fil)
